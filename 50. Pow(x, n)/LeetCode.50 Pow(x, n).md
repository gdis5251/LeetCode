# LeetCode.50 Pow(x, n)

**题目描述：实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。** 

> 这道题如果你非要return pow(x, n)那你就可跳过这篇伟大的博客了。哼！

**解题思路：**

我再做这道题的时候先用的是这种方法：

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        if (n < 0)
        {
            x = 1 / x;
            n = -n;
        }
        else if (n == 0)
        {
            return 1.0;
        }
        
        double mul = x;
        int i = 1;
        
        while (i < n)
        {
            x *= mul;
            i++;
        }
        
        return x;
        
    }
};
```

结果提示我超出时间限制！我一看测试用例（0.00001 2147483647 ）尼玛，这不超出才怪这么大一次一次循环。

于是我就自己想了好久，终于看了看评论区

### 二分折半法！！

这个办法的思路是，底数是什么无所谓的，把次方加起来等于参数传进来的次方就行。

人话：在数学里，有一个定理是，**底数相同但次方不同的两个数相乘，底数不变，次方相加。**

就是说，**咱们把次方变成二进制格式**。然后每次**除二就相当于将这个二进制数右移一位**，如果在1这个位置是1，那么就乘底数（底数在每次循环都乘自己，相当于一直平方，也符合二进制每一位都是前一位的平方）直到将次方变成0（也就是说将二进制的有效位都右移完了）结束。

再判断一下开始给进来的次方是不是小于0，如果小于0返回倒数，否则正常返回。

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        double res = 1.0;
        for(int i = n; i != 0; i /= 2){//除以2，相当于右移一位
            if(i % 2 != 0){//如果是奇数，说明1的位置为1，所以需要乘了，如果是0，任何数的0次方为1，1乘任何数还是任何数，所以不需要乘了
                res *= x;
            }
            x *= x;//这里就是每次为当前x的平方
            
            if (res == 0)
            {
                break;
            }
        }
        return  n < 0 ? 1 / res : res;
 
    }
};
```

