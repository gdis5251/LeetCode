# LeetCode 209. 长度最小的子数组（双指针法）

**题目描述：**

给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的连续子数组**。**如果不存在符合条件的连续子数组，返回 0。

**示例:** 

```
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
```

**进阶:**

如果你已经完成了*O*(*n*) 时间复杂度的解法, 请尝试 *O*(*n* log *n*) 时间复杂度的解法。



**解题思路：**

看代码讲：

```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        if (s<=0||nums.size()==0) return 0;
        int i=0,j=0,sum=0,minL=INT_MAX;
        for (;j<nums.size();j++)
        {
            sum+=nums[j];
            while (sum>=s)
            {
                minL=min(minL,j-i+1);
                sum-=nums[i++];
            }
        }
        if (minL==INT_MAX) return 0;
        return minL;
    }
};
```

既然是双指针法，我们用两个指针来维护一个框子，这里我们定义两个变量```i   j```都表示数组下标。只不过```i```始终表示这个框子的第一个元素，```j```始终表示框子的最后一个元素。

在一个大循环里，如果这个框子里面的值满足条件```>= s```就计算一下，看看这个框子当前的大小是否小于最小的那一次```minL```。

里面的```while```循环意思是，试想一下如果最后一个加的值非常大，说不定他一个值就大于前面的s了，那么是不是框子前面的元素都多余了，我们就让```i```往后走，直到不满足条件为止，在这个过程中，我们一直在缩小框子，那么就会找到框子最小的时候了，给```minL```赋值就行。